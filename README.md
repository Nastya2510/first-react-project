## My first react project
***

>React — это инструмент для создания пользовательских интерфейсов. Его главная задача — обеспечение вывода на экран того, что можно видеть на веб-страницах.

В данном проекте я делала перенос готовой верстки на React.
Верстка представляла собой небольшой сайт-порфтолио с тремя страницами и базовыми блоками.

***Главная задача*** - создать отдельные компонены с кодом, которые подключались бы между собой и при необходимости могли использоваться в других проектах. 
>Благодаря разбиению каждой страницы на небольшие фрагменты react значительно облегчает создание интерфейсов.

Список проектов в порфолио был описан в виде массива и находится в ***projectsList.js.***
Каждый проект описывается в виде объекта (свойство: значение). Далее на основе массива ***projects*** нужно вывести компоненты для каждого проекта, используя данные из созданного массива.

Для этого использовался метод ***map().*** Он выполняет действия к каждому элементу массива и по итогу возвращает новый массив, т.е. обрабатывает содержимое массива. В данном случае метод возвращает ***JSX-разметку.***

***Вторая задача*** - передавать данные в компонент. Это можно сделать с помощью свойств (props). Эти свойства мы можем создавать самостоятельно.

Мы можем передавать несколько свойств при вызове компонента и потом использовать их внутри этого компонента, выводить их в месте необходимости.

Здесь я познакомилась с понятием деструктуризации.

>***Деструктуризация*** — это свойство JavaScript, которое используется для извлечения частей данных из массива или объектов и назначения их новым переменным, созданным разработчиком.

При работе с массивом объектов в React необходимо использовать уникальный ключ.

В нашей ситуации с массивом из проектов - Если данные какого-то проекта изменятся, то React запомнит ключ, где произошло изменение и обновит только эту карточку, а не всю страницу. Мы используем map(), поэтому в качестве ключа допустимо ипользовать индекс.

В иных случаях индекс не желательно использовать, так как он является не постоянным идентификатором. В идеале - отдельно прописывать id.

>В данном проекте я взяла за правильно выносить все, что можно в отдельный компонент.

Чтобы ссылки открывали в новом окне, необходимо использовать ***target="blank"***

### Перемещение по страницам
Для реализации перемещения по страницам в React нужно использовать пакет ***react-router-dom.*** Логично, что для использования роутера его для начала нужно подключить.

Роутинг:
1. Ссылки на другие страницы.
2. Подмены страниц.
3. Перемещение по страницам.

Routes - это сами маршруты. Определяются через компонент ***Route***

При перемещении возникла проблема с прокручиванием скролла. Она была решена готовым решением из документации React.

Для отдельных проектов были сделаны отдельные страницы и маршруты. Тут имеется в виду страница с содержанием всех проектов и клики по ним. По клику переходим на отдельную страницу конкретного проекта.

> Заметка: В return находится JSX разметка, которая рендерится. Функции и константы описываются выше.

### Кнопка переключения темы

Работа с кнопкой подразумевала следующее:
1. При нажатии на кнопку меняются стили.
2. При установлии стиля и открытии страницы в новом окне стиль должен быть как и на текущей странице. Нужно использовать LocalStorage.
3. По-умолчанию тема страницы должна быть такая же, как и тема и пользователя в системных настройках на ПК (настройки системы пользователя).

Необходимо было связать ***LocalStorage*** и состояние(темы). Для этого надо использовать кастомные хуки.

>Можно создавать собственные хуки, т.е. собственные функции, которые будут использовать хуки react, как бы дополняя их нужным нам функционалом.

### Компонент BtnDarkMode отвечает за темную тему сайта

1. Тспользовались хуки react useEffect и useRef.
2. Использовались кастомные хуки useLocalStorage.
3. В BtnRef завели ссылку на кнопку, чтобы к ней обращаться.
4. В рендере кнопки используем ***onClick()*** и указываем, что по клику сработает ***toggleDarkMode()*** -> который обращается к состоянию ***setDarkMode*** и меняет тему.
5. Использовали хуки: 
   useEffect срабатывает на старке и при любом изменении темы.
   useEffect срабатывает только при старте и вешает прослушку на системные настройки.
